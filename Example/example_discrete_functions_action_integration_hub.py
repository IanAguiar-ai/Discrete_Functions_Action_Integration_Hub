# -*- coding: utf-8 -*-
"""Example_Discrete_Functions_Action_Integration_Hub.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vR5JQD7xSdInIqCYYoY4WZrrwmo6Opjg

## How to download:
"""

! pip install git+https://github.com/IanAguiar-ai/Discrete_Functions_Action_Integration_Hub

"""## Importing library:"""

from discrete_function import *

"""# Functionalities:

## Creating a discrete function:

$poisson(X = x) = \frac{\lambda^x * e^{-\lambda}}{x!}$
"""

def poisson(x:int, lambda_:float):
  def fatorial(n_):
    n = 1
    for i in range(2, n_ + 1):
      n *= i
    return n

  return (lambda_**x * 2.718281 ** (-lambda_))/fatorial(x)

"""## Passing the function to the class:"""

model = discrete_function(poisson, lambda_ = 3)

print(model)

"""## Getting function values:"""

print(model[0:10])

"""Note that the values were obtained where x goes from 0 to 10 including 10.

## Getting the accumulated values:
"""

print(model.accumulated(0, 10))

"""## Randomly taking samples according to this probability function."""

print(model.random(20))

"""Conditional Probability:"""

print(model[1:2] | model[1:4])

print(model[2,4,6] | model[0:6])

"""## Fitting curve parameter according to data:"""

sample = [poisson(i, lambda_ = 3.48261) for i in range(10)]
parameter = model.adjust_to_curve(name_param ='lambda_',
                                  curve = sample,
                                  initial_value = 1,
                                  plot = True,
                                  times = 1)

print(parameter)

"""### Example with more than one parameter:"""

def double_poisson(x:int, lambda_1:float, lambda_2:float, p):
  return poisson(x, lambda_1) * p + poisson(x, lambda_2) * (1 - p)

from random import random, seed
seed(1)

model_2 = discrete_function(double_poisson, lambda_1 = 1, lambda_2 = 1, p = 0.5)

sample = [double_poisson(i, lambda_1 = 3.48261, lambda_2 = 10.8362, p = 0.6) for i in range(20)]
parameter = model_2.adjust_to_curve(name_param = ['lambda_1', 'lambda_2', 'p'],
                                  curve = sample,
                                  initial_value = 1,
                                  plot = True,
                                  times = 6,
                                  max_iterations = 30)

"""Note that by increasing the number of iterations and 'times', convergence and therefore accuracy will be greater.

### An example with noise:
"""

seed(1)

model_2 = discrete_function(double_poisson, lambda_1 = 1, lambda_2 = 1, p = 0.5)

sample = [double_poisson(i, lambda_1 = 3.48261, lambda_2 = 10.8362, p = 0.6) + random() * 0.05 - 0.025 for i in range(20)]
parameter = model_2.adjust_to_curve(name_param = ['lambda_1', 'lambda_2', 'p'],
                                  curve = sample,
                                  initial_value = 1,
                                  plot = True,
                                  times = 6,
                                  max_iterations = 20)

"""### You can still order the chart individually:

Way 1:
"""

model_2.plot()

model_2.plot([1,10])

"""Way 2:"""

model_2[:32].plot()

model_2[1:10].plot()

"""Notice that when I plot the second way the curves are smoothed.

## Testing which model best fits the data:

Functions:
"""

from math import gamma

def fat(n:int):
    try:
        return gamma(n + 1)
    except:
        return 0

def poisson(x:int, lambda_:float):
    return 2.71828182**(-lambda_) * (lambda_**x)/fat(x)

def normal(x:int, mi:float, sigma:float):
    try:
        return (2.7182**(-(1/2)*((x - mi)/sigma)**2)) / (sigma * (2*3.1415)**(1/2))
    except:
        return 0

"""models:"""

from discrete_function import adjust_sample_on

curve = [normal(i, mi = 6.74, sigma = 4.25) + random() * 0.04 - 0.02 for i in range(0, 15)]

model_1 = discrete_function(poisson, lambda_ = 1)
model_2 = discrete_function(normal, sigma = 1, mi = 1)
model_3 = discrete_function(double_poisson, lambda_1 = 1, lambda_2 = 1, p = 0.5)

best_model = adjust_sample_on(curve, [model_1, model_2, model_3],
                              plot = True)

"""Notice that he found the function that best fits the data:"""

print(best_model)
best_model[-6:20].plot()

"""### With a non-sequential x:"""

x = [0, 3, 5, 6, 7, 11, 15]

curve = [normal(i, mi = 6.74, sigma = 4.25) + random() * 0.01 - 0.005 for i in x]

model_1 = discrete_function(poisson, lambda_ = 1)
model_2 = discrete_function(normal, sigma = 1, mi = 1)
model_3 = discrete_function(double_poisson, lambda_1 = 1, lambda_2 = 1, p = 0.5)

best_model = adjust_sample_on(curve = curve,
                              models = [model_1, model_2, model_3],
                              x = x,
                              plot = True)

"""### Example with sine:"""

from math import sin, cos

def s2(x, a, b):
    return sin(x*a) + sin(x*b)

def c2(x, a, b):
    return cos(x*a) + cos(x*b)

model_1 = discrete_function(s2, a = 1, b = 1)
model_2 = discrete_function(c2, a = 1, b = 1)

x = [i * 0.1 for i in range(10)]
curve = [s2(i, a = 3, b = 7) for i in x]

best_model = adjust_sample_on(curve = curve, x = x,
                              models = [model_1, model_2],
                              times = 10,
                              initial_value = 0.1,
                              plot = True)

"""## Function mixes:"""

def s(x, sa, **args): #sin
    return sin(x*sa)

def c(x, ca, **args): #cos
    return cos(x*ca)

"""### Mixing:"""

model_1 = discrete_function(s)
model_2 = discrete_function(c)

final_model = model_1 + model_2

x = [i * 0.1 for i in range(10)]
curve = [s(i, sa = 3) + c(i, ca = 4) for i in x]

best_model = adjust_sample_on(curve = curve, x = x,
                              models = [final_model],
                              times = 20,
                              initial_value = 0.1,
                              plot = True)

"""### Complex mixtures:"""

def linear(x, la, lb, **args):
  return la + x*lb

model_1 = discrete_function(s)
model_2 = discrete_function(c)
model_3 = discrete_function(linear)

final_model = (model_1 + model_2 - 1) * (model_3/3)

x = [i * 0.1 for i in range(10)]
curve = [(s(i, sa = 3) + c(i, ca = 20) - 1) * (linear(i, la = 12, lb = 40)/3) for i in x]

best_model = adjust_sample_on(curve = curve, x = x,
                              models = [final_model],
                              times = 15,
                              initial_value = 0.1,
                              plot = True)

"""## Regression:

Sample and function:
"""

x = [3, 3, 3, 29, 29, 29, 79, 79, 79, 127, 127, 127,
     165, 165, 165, 300, 300, 300, 248, 248, 248,
     200, 200, 200, 317, 317, 317, 156, 156, 156]

y = [37, 37, 37, 58, 58, 58, 57, 58, 57, 67,
     66, 66, 67, 68, 68, 74, 75, 75, 81, 81,
     81, 74, 74, 75, 75, 75, 75, 79, 78, 77]

y = list(map(lambda x: -x, y))

from math import log
def model_regression(x:float, a, b):
    return -a + 20 * log(max(b, 0.001)/max(x, 0.001), 10)

"""Creating model:"""

regression = Discrete_function(model_regression)

best = adjust_sample_on(curve = y, x = x,
                        models = [regression],
                        times = 12,
                        initial_value = 0.1,
                        plot = False)

"""Plotting with the samples:"""

best.plot([0, 300], curve = [x, y])

"""## Evaluating the function:"""

def func(x, a, b, c):
  a = b + c
  b = a + c
  c = (b + a) * (b - a)
  b = c/(b+a)
  return b

model = Df(func) #Df is the same as Discrete_function

model.evaluate()

"""## Change error function:

New error function:
"""

def error_new(curve_1:list, curve_2:list):
    resp:float = 0
    if len(curve_1) != len(curve_2):
        raise "Different list sizes"
    for a, b in zip(curve_1, curve_2):
        resp:float = (a - b)*(a - b) + resp
        if a > b:
            resp*=2
    return resp

regression = Discrete_function(model_regression)
regression.function_error = error_new

best = adjust_sample_on(curve = y, x = x,
                        models = [regression],
                        times = 6,
                        initial_value = 0.1,
                        plot = True)

best.residual()